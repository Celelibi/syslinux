Syslinux LUA User Guide
=======================
Marcel Ritter <Marcel.Ritter@rrze.uni-erlangen.de>

Invocation
----------

Running +lua.c32+ only results in an interactive shell.
......................................................
KERNEL lua.c32
......................................................

By using the +APPEND+ parameter you can specify a lua
script to be executed:
......................................................
KERNEL lua.c32
APPEND /testit.lua
......................................................

Modules
-------

Modules must be explicitly loaded into the namespace
before use, for example:
......................................................
local sl = require "syslinux"
......................................................
Using +local+, as above, is good practice in scripts, but it must be
omitted when working interactively.

SYSLINUX
~~~~~~~~

.version()

Returns version string

.derivative()

Returns running Syslinux's derivative (ISOLINUX, PXELINUX or SYSLINUX).

.sleep(s)

Sleep for +s+ seconds

.msleep(ms)

Sleep for +ms+ milliseconds

.run_command(command)

Execute syslinux command line +command+.

_Example_:
......................................................
local sl = require "syslinux"
sl.run_command("memdisk initrd=/dos/BIOS/FSC-P7935-108.img raw")
......................................................

.run_default()

FIXME

.local_boot()

FIXME

.final_cleanup()

FIXME

.boot_linux(kernel, cmdline, [mem_limit], [videomode])

FIXME

.IMAGE_TYPE

A table containing the possible kernel types for +run_kernel_image()+.

.run_kernel_image(kernel, cmdline, ipappend_flags, type)

Run the specified kernel. +type+ is one of the values of the +IMAGE_TYPE+ table.

FIXME

.loadfile(filname)

Load file +filename+

.filesize(file)

Return size of +file+ (loaded by loadfile())

.filename(file)

Return name of +file+ (loaded by loadfile())

.initramfs_init()

Return empty initramfs object

.initramfs_load_archive(initramfs, filename)

Load contents of +filename+ into +initramfs+. Initialize
+initramfs+ with initramfs_init() before use.

.initramfs_add_file(initramfs, file)

Adds +file+ to +initramfs+. +initramfs+ needs to be
initialized, +file+ has been loaded by loadfile().

_Example_:
......................................................
local sl = require "syslinux"

-- get nice output
printf = function(s,...)
           return io.write(s:format(...))
         end -- function

kernel = sl.loadfile("/SuSE-11.1/x86_64/linux")

printf("Filename/size: %s %d\n", sl.filename(kernel), sl.filesize(kernel))

initrd = sl.loadfile("/SuSE-11.1/x86_64/initrd")

printf("Filename/size: %s %d\n", sl.filename(initrd), sl.filesize(initrd))

initrd = sl.initramfs_init()
sl.initramfs_load_archive(initrd, "/SuSE-11.1/x86_64/initrd");

sl.boot_it(kernel, initrd, "init=/bin/bash")
......................................................

.KEY

Table containing the return values of +get_key()+ for special (eg. function)
keys.

.KEY_CTRL(key)

Return the code for the Ctrl-modified version of the given ASCII code.

.get_key(timeout)

Wait at most +timeout+ ms for a key press.
Return the ASCII code of the pressed key, some other value of the +KEY+
table, or +KEY.NONE+ on timeout.


DMI
~~~

.supported()

Returns +true+ if DMI is supported on machine, +false+ otherwise.

.gettable()

Returns a list of key-value pairs. The key is one of the DMI property strings:
FIXME list

_Example_:
......................................................
local sl = require "syslinux"
local dmi = require "dmi"

if (dmi.supported()) then

  dmitable = dmi.gettable()

  for k,v in pairs(dmitable) do
    print(k, v)
  end

  print(dmitable.system.manufacturer)
  print(dmitable.system.product_name)
  print(dmitable.bios.bios_revision)

  if ( string.match(dmitable.system.product_name, "ESPRIMO P7935") ) then
    print("Matches")
    sl.run_command("memdisk initrd=/dos/BIOS/FSC-P7935-108.img raw")
  else
    print("Does not match")
    sl.run_command("memdisk initrd=/dos/BIOS/FSC-P7935-108.img raw")
  end

end
......................................................


PCI
~~~

.getinfo()

Return list of value pairs (device_index, device) of all PCI devices.

.getidlist(filename)

Load a tab separated list of PCI IDs and their description. 
Sample files can be found here: http://pciids.sourceforge.net/


_Example_:
......................................................
local pci = require "pci"

-- get nice output
printf = function(s,...)
           return io.write(s:format(...))
         end

-- get device info
pciinfo = pci.getinfo()

-- get plain text device description
pciids = pci.getidlist("/pci.ids")

-- list all pci busses
for dind,device in pairs(pciinfo) do

  -- search for device description
  search = string.format("%04x%04x", device.vendor, device.product)

  printf(" %04x:%04x:%04x:%04x = ", device.vendor, device.product,
			device.sub_vendor, device.sub_product)

  if ( pciids[search] ) then
         printf("%s\n", pciids[search])
  else
         printf("Unknown\n")
  end
end

-- print(pciids["8086"])
-- print(pciids["10543009"])
-- print(pciids["00700003"])
-- print(pciids["0070e817"])
-- print(pciids["1002437a1002437a"])
......................................................


VESA
~~~~

.getmodes()

Return list of available VESA modes.

_Example_:
......................................................
local vesa = require "vesa"

-- get nice output
printf = function(s,...)
           return io.write(s:format(...))
         end

-- list available vesa modes
for mind,mode in pairs(vesa.getmodes()) do
   printf("%04x: %dx%dx%d\n", mode.mode, mode.hres, mode.vres, mode.bpp)
end
......................................................


.setmode()

Set (only currently supported) VESA mode.

.load_background(filename)

Load +filename+ from TFTP, and use it as background image.

_Example_:
......................................................
local sl = require "syslinux"
local vesa = require "vesa"

-- get nice output
printf = function(s,...)
           return io.write(s:format(...))
         end

-- lets go to graphics land
vesa.setmode()

printf("Hello World! - VESA mode")

-- some text to display "typing style"
textline=[[
From syslinux GSOC 2009 home page:

Finish the Lua engine

We already have a Lua interpreter integrated with the Syslinux build. However, right now it is not very useful. We need to create a set of bindings to the Syslinux functionality, and have an array of documentation and examples so users can use them.

This is not a documentation project, but the documentation deliverable will be particularly important for this one, since the intended target is system administrators, not developers.
]]


-- do display loop
-- keep in mind: background change will not erase text!
while ( true ) do

vesa.load_background("/background1.jpg")

sl.sleep(1)

for i = 1, #textline do
    local c = textline:sub(i,i)
    printf("%s", c)
    sl.msleep(200)
end

sl.sleep(10)
......................................................
